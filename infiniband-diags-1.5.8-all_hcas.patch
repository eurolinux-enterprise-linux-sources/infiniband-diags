diff -up infiniband-diags-1.5.12/src/perfquery.c.hcas infiniband-diags-1.5.12/src/perfquery.c
--- infiniband-diags-1.5.12/src/perfquery.c.hcas	2011-11-02 01:31:40.000000000 -0400
+++ infiniband-diags-1.5.12/src/perfquery.c	2012-08-22 15:29:50.838358011 -0400
@@ -368,9 +368,10 @@ static void reset_counters(int extended,
 }
 
 static int reset, reset_only, all_ports, loop_ports, port, extended, xmt_sl,
-    rcv_sl, xmt_disc, rcv_err, extended_speeds, smpl_ctl, oprcvcounters, flowctlcounters,
-    vloppackets, vlopdata, vlxmitflowctlerrors, vlxmitcounters, swportvlcong,
-    rcvcc, slrcvfecn, slrcvbecn, xmitcc, vlxmittimecc;
+    rcv_sl, xmt_disc, rcv_err, extended_speeds, smpl_ctl, oprcvcounters,
+    flowctlcounters, vloppackets, vlopdata, vlxmitflowctlerrors,
+    vlxmitcounters, swportvlcong, rcvcc, slrcvfecn, slrcvbecn, xmitcc,
+    vlxmittimecc, all_hcas;
 
 static void common_func(ib_portid_t * portid, int port_num, int mask,
 			unsigned query, unsigned reset,
@@ -604,12 +605,16 @@ static int process_opt(void *context, in
 	case 'R':
 		reset_only++;
 		break;
+	case 'H':
+		all_hcas++;
+		break;
 	default:
 		return -1;
 	}
 	return 0;
 }
 
+#define MAX_NAMES 10
 int main(int argc, char **argv)
 {
 	int mgmt_classes[4] = { IB_SMI_CLASS, IB_SMI_DIRECT_CLASS, IB_SA_CLASS,
@@ -624,6 +629,10 @@ int main(int argc, char **argv)
 	int start_port = 1;
 	int enhancedport0;
 	int i;
+	int names;
+	int cur_name = 0;
+	char name_list[MAX_NAMES][UMAD_CA_NAME_LEN];
+	umad_ca_t ca;
 
 	const struct ibdiag_opt opts[] = {
 		{"extended", 'x', 0, NULL, "show extended port counters"},
@@ -646,6 +655,7 @@ int main(int argc, char **argv)
 		{"vlxmittimecc", 12, 0, NULL, "show VL Xmit Time congestion control counters"},
 		{"smplctl", 'c', 0, NULL, "show samples control"},
 		{"all_ports", 'a', 0, NULL, "show aggregated counters"},
+		{"all_hcas", 'H', 0, NULL, "iterate through all local HCAs and ports"},
 		{"loop_ports", 'l', 0, NULL, "iterate through each port"},
 		{"reset_after_read", 'r', 0, NULL, "reset counters after read"},
 		{"Reset_only", 'R', 0, NULL, "only reset counters"},
@@ -654,10 +664,12 @@ int main(int argc, char **argv)
 	char usage_args[] = " [<lid|guid> [[port] [reset_mask]]]";
 	const char *usage_examples[] = {
 		"\t\t# read local port's performance counters",
+		"-H\t\t# read performance counters on all local HCAs/ports",
 		"32 1\t\t# read performance counters from lid 32, port 1",
 		"-x 32 1\t# read extended performance counters from lid 32, port 1",
 		"-a 32\t\t# read performance counters from lid 32, all ports",
 		"-r 32 1\t# read performance counters and reset",
+		"-r -H\t\t# read and reset counters on all local HCAs/ports",
 		"-x -r 32 1\t# read extended performance counters and reset",
 		"-R 0x20 1\t# reset performance counters of port 1 only",
 		"-x -R 0x20 1\t# reset extended performance counters of port 1 only",
@@ -673,186 +685,244 @@ int main(int argc, char **argv)
 	argc -= optind;
 	argv += optind;
 
+	if (all_hcas && argc > 0)
+		IBERROR("Invalid input: all_hcas and any port/lid/guid are "
+			"not allowed together.");
+	if (all_hcas && (loop_ports || all_ports || (port==ALL_PORTS)))
+		IBERROR("Invalid input: all_hcas can not be combined with "
+			"loop_ports or all_ports or port == ALL_PORTS");
+
 	if (argc > 1)
 		port = strtoul(argv[1], 0, 0);
 	if (argc > 2)
 		mask = strtoul(argv[2], 0, 0);
 
-	srcport = mad_rpc_open_port(ibd_ca, ibd_ca_port, mgmt_classes, 4);
-	if (!srcport)
-		IBERROR("Failed to open '%s' port '%d'", ibd_ca, ibd_ca_port);
-
-	if (argc) {
-		if (ib_resolve_portid_str_via(&portid, argv[0], ibd_dest_type,
-					      ibd_sm_id, srcport) < 0)
-			IBERROR("can't resolve destination port %s", argv[0]);
-	} else {
-		if (ib_resolve_self_via(&portid, &port, 0, srcport) < 0)
-			IBERROR("can't resolve self port %s", argv[0]);
-	}
+	if (all_hcas) {
+		if (umad_init() < 0)
+			IBERROR("Failed to initialize libibumad");
+		if ((names = umad_get_cas_names(name_list, MAX_NAMES)) < 0)
+			IBERROR("Unable to get list of HCAs");
+		cur_name = 0;
+		if (umad_get_ca(name_list[cur_name], &ca))
+			IBERROR("Unable to get umad ca");
+		ibd_ca = name_list[cur_name++];
+		ibd_ca_port = start_port;
+	}
+
+	do {
+		if (all_hcas && strncmp(ca.ports[ibd_ca_port]->link_layer,
+					"InfiniBand", 10))
+			goto skip_port;
+
+		srcport = mad_rpc_open_port(ibd_ca, ibd_ca_port,
+					    mgmt_classes, 4);
+		if (!srcport) {
+			if (cur_name == 0)
+				IBERROR("Failed to open '%s' port '%d'",
+					ibd_ca, ibd_ca_port);
+			exit(0);
+		}
 
-	/* PerfMgt ClassPortInfo is a required attribute */
-	memset(pc, 0, sizeof(pc));
-	if (!pma_query_via(pc, &portid, port, ibd_timeout, CLASS_PORT_INFO,
-			   srcport))
-		IBERROR("classportinfo query");
-	/* ClassPortInfo should be supported as part of libibmad */
-	memcpy(&cap_mask, pc + 2, sizeof(cap_mask));	/* CapabilityMask */
-	if (!(cap_mask & IB_PM_ALL_PORT_SELECT)) {	/* bit 8 is AllPortSelect */
-		if (!all_ports && port == ALL_PORTS)
-			IBERROR("AllPortSelect not supported");
-		if (all_ports)
-			all_ports_loop = 1;
-	}
+		if (argc) {
+			if (ib_resolve_portid_str_via(&portid, argv[0],
+						      ibd_dest_type,
+						      ibd_sm_id, srcport) < 0)
+				IBERROR("can't resolve destination port %s",
+					argv[0]);
+		} else {
+			if (ib_resolve_self_via(&portid, &port, 0, srcport) < 0)
+				IBERROR("can't resolve self port %s", argv[0]);
+		}
 
-	if (xmt_sl) {
-		xmt_sl_query(&portid, port, mask);
-		goto done;
-	}
+		/* PerfMgt ClassPortInfo is a required attribute */
+		memset(pc, 0, sizeof(pc));
+		if (!pma_query_via(pc, &portid, port, ibd_timeout,
+				   CLASS_PORT_INFO, srcport))
+			IBERROR("classportinfo query");
+		/* ClassPortInfo should be supported as part of libibmad */
+		memcpy(&cap_mask, pc + 2, sizeof(cap_mask));/* CapabilityMask */
+		if (!(cap_mask & IB_PM_ALL_PORT_SELECT)) {	/* bit 8 is AllPortSelect */
+			if (!all_ports && port == ALL_PORTS)
+				IBERROR("AllPortSelect not supported");
+			if (all_ports)
+				all_ports_loop = 1;
+		}
 
-	if (rcv_sl) {
-		rcv_sl_query(&portid, port, mask);
-		goto done;
-	}
+		if (xmt_sl) {
+			xmt_sl_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (xmt_disc) {
-		xmt_disc_query(&portid, port, mask);
-		goto done;
-	}
+		if (rcv_sl) {
+			rcv_sl_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (rcv_err) {
-		rcv_err_query(&portid, port, mask);
-		goto done;
-	}
+		if (xmt_disc) {
+			xmt_disc_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (extended_speeds) {
-		extended_speeds_query(&portid, port, mask);
-		goto done;
-	}
+		if (rcv_err) {
+			rcv_err_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (oprcvcounters) {
-		oprcvcounters_query(&portid, port, mask);
-		goto done;
-	}
+		if (extended_speeds) {
+			extended_speeds_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (flowctlcounters) {
-		flowctlcounters_query(&portid, port, mask);
-		goto done;
-	}
+		if (oprcvcounters) {
+			oprcvcounters_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (vloppackets) {
-		vloppackets_query(&portid, port, mask);
-		goto done;
-	}
+		if (flowctlcounters) {
+			flowctlcounters_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (vlopdata) {
-		vlopdata_query(&portid, port, mask);
-		goto done;
-	}
+		if (vloppackets) {
+			vloppackets_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (vlxmitflowctlerrors) {
-		vlxmitflowctlerrors_query(&portid, port, mask);
-		goto done;
-	}
+		if (vlopdata) {
+			vlopdata_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (vlxmitcounters) {
-		vlxmitcounters_query(&portid, port, mask);
-		goto done;
-	}
+		if (vlxmitflowctlerrors) {
+			vlxmitflowctlerrors_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (swportvlcong) {
-		swportvlcong_query(&portid, port, mask);
-		goto done;
-	}
+		if (vlxmitcounters) {
+			vlxmitcounters_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (rcvcc) {
-		rcvcc_query(&portid, port, mask);
-		goto done;
-	}
+		if (swportvlcong) {
+			swportvlcong_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (slrcvfecn) {
-		slrcvfecn_query(&portid, port, mask);
-		goto done;
-	}
+		if (rcvcc) {
+			rcvcc_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (slrcvbecn) {
-		slrcvbecn_query(&portid, port, mask);
-		goto done;
-	}
+		if (slrcvfecn) {
+			slrcvfecn_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (xmitcc) {
-		xmitcc_query(&portid, port, mask);
-		goto done;
-	}
+		if (slrcvbecn) {
+			slrcvbecn_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (vlxmittimecc) {
-		vlxmittimecc_query(&portid, port, mask);
-		goto done;
-	}
+		if (xmitcc) {
+			xmitcc_query(&portid, port, mask);
+			goto done;
+		}
 
-	if (smpl_ctl) {
-		dump_portsamples_control(&portid, port);
-		goto done;
-	}
+		if (vlxmittimecc) {
+			vlxmittimecc_query(&portid, port, mask);
+			goto done;
+		}
 
+		if (smpl_ctl) {
+			dump_portsamples_control(&portid, port);
+			goto done;
+		}
 
-	if (all_ports_loop || (loop_ports && (all_ports || port == ALL_PORTS))) {
-		if (smp_query_via(data, &portid, IB_ATTR_NODE_INFO, 0, 0,
-				  srcport) < 0)
-			IBERROR("smp query nodeinfo failed");
-		node_type = mad_get_field(data, 0, IB_NODE_TYPE_F);
-		mad_decode_field(data, IB_NODE_NPORTS_F, &num_ports);
-		if (!num_ports)
-			IBERROR("smp query nodeinfo: num ports invalid");
 
-		if (node_type == IB_NODE_SWITCH) {
-			if (smp_query_via(data, &portid, IB_ATTR_SWITCH_INFO,
+		if (all_ports_loop ||
+		    (loop_ports && (all_ports || port == ALL_PORTS))) {
+			if (smp_query_via(data, &portid, IB_ATTR_NODE_INFO,
 					  0, 0, srcport) < 0)
 				IBERROR("smp query nodeinfo failed");
-			enhancedport0 =
-			    mad_get_field(data, 0, IB_SW_ENHANCED_PORT0_F);
-			if (enhancedport0)
-				start_port = 0;
-		}
-		if (all_ports_loop && !loop_ports)
-			IBWARN
-			    ("Emulating AllPortSelect by iterating through all ports");
-	}
+			node_type = mad_get_field(data, 0, IB_NODE_TYPE_F);
+			mad_decode_field(data, IB_NODE_NPORTS_F, &num_ports);
+			if (!num_ports)
+				IBERROR("smp query nodeinfo: num ports invalid");
+
+			if (node_type == IB_NODE_SWITCH) {
+				if (smp_query_via(data, &portid,
+						  IB_ATTR_SWITCH_INFO,
+						  0, 0, srcport) < 0)
+					IBERROR("smp query nodeinfo failed");
+				enhancedport0 =
+					mad_get_field(data, 0,
+						      IB_SW_ENHANCED_PORT0_F);
+				if (enhancedport0)
+					start_port = 0;
+			}
+			if (all_ports_loop && !loop_ports)
+				IBWARN ("Emulating AllPortSelect by iterating "
+					"through all ports");
+		}
 
-	if (reset_only)
-		goto do_reset;
+		if (reset_only)
+			goto do_reset;
 
-	if (all_ports_loop || (loop_ports && (all_ports || port == ALL_PORTS))) {
-		for (i = start_port; i <= num_ports; i++)
+		if (all_ports_loop ||
+		    (loop_ports && (all_ports || port == ALL_PORTS))) {
+			for (i = start_port; i <= num_ports; i++)
+				dump_perfcounters(extended, ibd_timeout,
+						  cap_mask, &portid, i,
+						  (all_ports_loop &&
+						   !loop_ports));
+			if (all_ports_loop && !loop_ports) {
+				if (extended != 1)
+					output_aggregate_perfcounters(&portid,
+								      cap_mask);
+				else
+					output_aggregate_perfcounters_ext(&portid,
+									  cap_mask);
+			}
+		} else
 			dump_perfcounters(extended, ibd_timeout, cap_mask,
-					  &portid, i, (all_ports_loop
-						       && !loop_ports));
-		if (all_ports_loop && !loop_ports) {
-			if (extended != 1)
-				output_aggregate_perfcounters(&portid,
-							      cap_mask);
-			else
-				output_aggregate_perfcounters_ext(&portid,
-								  cap_mask);
-		}
-	} else
-		dump_perfcounters(extended, ibd_timeout, cap_mask, &portid,
-				  port, 0);
+					  &portid, port, 0);
 
-	if (!reset)
-		goto done;
+		if (!reset)
+			goto done;
 
 do_reset:
-	if (argc <= 2 && !extended && (cap_mask & IB_PM_PC_XMIT_WAIT_SUP))
-		mask |= (1 << 16);	/* reset portxmitwait */
-
-	if (all_ports_loop || (loop_ports && (all_ports || port == ALL_PORTS))) {
-		for (i = start_port; i <= num_ports; i++)
-			reset_counters(extended, ibd_timeout, mask, &portid, i);
-	} else
-		reset_counters(extended, ibd_timeout, mask, &portid, port);
+		if (argc <= 2 && !extended &&
+		    (cap_mask & IB_PM_PC_XMIT_WAIT_SUP))
+			mask |= (1 << 16);	/* reset portxmitwait */
+
+		if (all_ports_loop ||
+		    (loop_ports && (all_ports || port == ALL_PORTS)))
+			for (i = start_port; i <= num_ports; i++)
+				reset_counters(extended, ibd_timeout, mask,
+					       &portid, i);
+		else
+			reset_counters(extended, ibd_timeout, mask,
+				       &portid, port);
 
 done:
-	mad_rpc_close_port(srcport);
+		mad_rpc_close_port(srcport);
+skip_port:
+		if (all_hcas) {
+			if (ibd_ca_port < ca.numports)
+				ibd_ca_port++;
+			else {
+				umad_release_ca(&ca);
+				if (umad_get_ca(name_list[cur_name], &ca))
+					/*
+					 * We're done, the next name in the
+					 * list was empty, exit gracefully
+					 */
+					exit(0);
+				ibd_ca = name_list[cur_name++];
+				ibd_ca_port = start_port;
+			}
+		} else
+			ibd_ca = NULL;
+	} while (ibd_ca);
 	exit(0);
 }
